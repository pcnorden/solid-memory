import cv2 as cv
import helper
import numpy as np
import math

src = cv.imread("images/dial_face_720p.png") # Originally dial_face.jpg
dst = cv.Canny(src, 50, 200, None, 3)
cdst = cv.cvtColor(dst, cv.COLOR_GRAY2BGR)
window_name = "HoughLinesP debugger"
trackbar_threshold = "HoughLinesP threshold:"
trackbar_minLineLenght = "HoughLinesP minLineLenght:"
trackbar_maxLineGap = "HoughLinesP maxLineGap:"
trackbar_circle1 = "Bigger circle:"
trackbar_circle2 = "Smaller circle:"
trackbar_blur = "Blur:"
tmpLineDegrees = []
trackbar_seperation = "Degree seperation:"

def within(val, list_arg, seperation):
	for x in list_arg:
		if val > x-seperation/10 and val < x+seperation/10:
			return True

def probable_division(degree_list):
	# This is a very dirty way to do this, but hopefully I'll be forgiven.
	# How this is supposed to work is that it will bruteforce guess to the closest matching
	# dial indicator face since all dial indicators have a minimum of 10 scale divisions.
	x = len(degree_list) # How many lines where found on the dial face?
	if x <= 0:
		return
	current_guess = 0
	last_value = 180
	loop = True
	while loop:
		#print("x: {}".format(x))
		current_guess += 10
		if 360/current_guess > 360/x:
			last_value = current_guess
		elif 360/current_guess <= 360/x:
			#print("Probable solution: {}".format(str(current_guess)))
			loop = False

def testing_fft(degree_list):
	if degree_list == None:
		return
	elif len(degree_list) < 2:
		return
	elif type(degree_list) == type(int()):
		return
	else:
		degree_list.sort()
		diff_list = []
		i = 0
		#for i in degree_list:
		#	print("Testing")
		for i in range(len(degree_list)):
			if i == 0:
				diff_list.append(degree_list[i]-degree_list[len(degree_list)-1]+360) # First item in the list we can't compare against previous
				# item since that would cause a out of bounds read, so just read the last item in the list and calculate the difference.
			elif i < len(degree_list):
				diff_list.append(degree_list[i]-degree_list[i-1])
		#for i in diff_list: Commented out because of console spam
			#print("%.2f"%i)

def update_v2(val):
	# This function will be called upon when any slider in the GUI is
	# moved
	global src
	# HoughLinesP Threshold
	threshold = cv.getTrackbarPos(trackbar_threshold, window_name)
	# HoughLinesP Minimum Line Lenght
	minLineLength = cv.getTrackbarPos(trackbar_minLineLenght, window_name)
	# HoughLinesP Maximum Line Lenght
	maxLineLength = cv.getTrackbarPos(trackbar_maxLineGap, window_name)
	# Maximum search diameter cirkle
	biggerCircle = cv.getTrackbarPos(trackbar_circle1, window_name)
	# Minimum search diameter cirkle

def update(val):
	global src
	threshold = cv.getTrackbarPos(trackbar_threshold, window_name)
	minLineLenght = cv.getTrackbarPos(trackbar_minLineLenght, window_name)
	maxLineGap = cv.getTrackbarPos(trackbar_maxLineGap, window_name)
	outer_circle_radius = cv.getTrackbarPos(trackbar_circle1, window_name)
	inner_circle_radius = cv.getTrackbarPos(trackbar_circle2, window_name)
	blur_value = cv.getTrackbarPos(trackbar_blur, window_name)
	seperation_value = cv.getTrackbarPos(trackbar_seperation, window_name)
	if seperation_value < 1 or seperation_value > 40:
		seperation_value = 0
	tmp = src
	if blur_value > 0 and blur_value <= 20:
		#tmp = cv.adaptiveThreshold(src, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 11, 2)
		#blur = cv.GaussianBlur(tmp, (blur_value, blur_value), 0)
		#closing = cv.morphologyEx(blur, cv.MORPH_CLOSE, (2,2))
		#tmp = cv.threshold(closing, 0, 255, cv.THRESH_BINARY+cv.THRESH_OTSU)
		tmp = cv.blur(src, (blur_value, blur_value))
	dst = cv.Canny(tmp, 150, 200, None, 3)
	cdst = cv.cvtColor(dst, cv.COLOR_GRAY2BGR)
	lines = cv.HoughLinesP(dst, 1, np.pi/180, threshold, None, minLineLenght, maxLineGap)
	# TODO: Implement length measuring of lines generated by above function
	# and if they are more than the difference between the circles, ignore that line


	# Pre-calculate the image center point for use in drawing circles and math
	img_height = int(cdst.shape[0]/2) # Image center point height
	img_width = int(cdst.shape[1]/2) # Image center point width
	if outer_circle_radius > 0:
		cv.circle(cdst, (img_height, img_width), outer_circle_radius, (255,255,255), 2)
	if inner_circle_radius > 0:
		cv.circle(cdst, (img_height, img_width), inner_circle_radius, (255,0,255), 2)
	if lines is not None:
		tmpLineDegrees.clear()
		plottedLines = []
		for i in range(0, len(lines)):
			l = lines[i][0]
			r1 = math.hypot(l[0]-img_height, l[1]-img_width)
			r2 = math.hypot(l[2]-img_height, l[3]-img_width)
			if r1 < outer_circle_radius and r1 > inner_circle_radius or r2 > inner_circle_radius and r2 < outer_circle_radius:
				if seperation_value != 0:
					degrees = math.degrees(math.atan2(l[0]-img_height, l[1]-img_width))
					if len(plottedLines) == 0:
						cv.line(cdst, (l[0], l[1]), (l[2], l[3]), (0,255,0), 3, cv.LINE_AA)
						plottedLines.append(degrees)
					else:
						if not within(degrees, plottedLines, seperation_value):
							cv.line(cdst, (l[0], l[1]), (l[2], l[3]), (0,255,0), 3, cv.LINE_AA)
							plottedLines.append(degrees)
							tmpLineDegrees.append(degrees)
						#for line in plottedLines:
						#	if degrees >= line-seperation_value/10 and degrees <= line-seperation_value/10:
						#		continue
						#	else:
						#		cv.line(cdst, (l[0], l[1]), (l[2], l[3]), (0,255,0), 3, cv.LINE_AA)
						#		plottedLines.append(degrees)
				#cv.line(cdst, (l[0], l[1]), (l[2], l[3]), (0,255,0), 3, cv.LINE_AA)
				#tmpLineDegrees.append(math.degrees(math.atan2(l[0]-1320, l[1]-1312)))
		probable_division(plottedLines)
		testing_fft(plottedLines)
	cdstCopy = helper.scale(cdst, 100)
	cv.imshow(window_name, cdstCopy)

# Creating some rough guesses for the cirle sizes
rough_radius_outer = int(src.shape[0]/2)
rough_radius_inner = int((src.shape[0]/2)*0.8)

cv.namedWindow(window_name)
cv.createTrackbar(trackbar_threshold, window_name, 100, 100, update)
cv.createTrackbar(trackbar_minLineLenght, window_name, 20, 400, update)
cv.createTrackbar(trackbar_maxLineGap, window_name, 15, 50, update)
cv.createTrackbar(trackbar_circle1, window_name, rough_radius_outer, int(src.shape[0]/2), update)
cv.createTrackbar(trackbar_circle2, window_name, rough_radius_inner, int(src.shape[1]/2), update)
cv.createTrackbar(trackbar_blur, window_name, 3, 20, update)
cv.createTrackbar(trackbar_seperation, window_name, 20, 40, update)
while True:
	# This part is a hack so that you're able to close the window using the 
	# close button instead of listening to keypresses like it was before
	# Source: https://stackoverflow.com/questions/13307606/closing-video-window-using-close-x-button-in-opencv-python
	keyCode = cv.waitKey(1)
	if cv.getWindowProperty(window_name, cv.WND_PROP_VISIBLE) < 1:
		break
cv.destroyAllWindows()